10 * 1 - 3 - 4 * 2 + 8 + 11 * 3
10 + 2 * 4
10 + 4 * 2 + 8
10 * 20
10 1 + 1 * (1 / 2) - 4

10 + 1 + 1 + 1

+
10 +
    1 +
      1 1


10
* 1
    - 3
        - 4
            * 2
                + 8
                    + 11
                        * 3



11 * 3 + 4 * 2
33 + 8
+
*       *
3 11    4 2


10 * 3 * 2

10 * 3
30 * 2

*
3 *
  10 *
     2


1 + 2 * 3

+
1   *
    2 3
---
4 * 2 + 3

aktuell
*
4   +
    2 3

1. schritt

*
4 2

2. schritt

+
3 *
  4 2

ziel
+
3   *
    4 2
---
4 * 2 * 3

aktuell
*
4   *
    2 3

1. schritt

*
4 2

2. schritt

*
3 *
  4 2

ziel
*
3   *
    4 2

# schauen ob die nächste operation eine plus
#   wenn plus:
#       plus in die root hängen
#   sonst wenn mult:
#

# wenn operation mult
#   wenn sibling digit:
#       digit und next digit als children
#       mult als child der vorherigen op
